esphome:
  name: b2500-ble-diag
  friendly_name: b2500-ble-diag
    #  platformio_options:
    #board_build.f_cpu: 160000000L
  includes:
    - b2500-v1-errorcodes.h
    - b2500-v2-errorcodes.h

esp32:
  #board: az-delivery-devkit-v4
  board: esp32dev
  framework:
    # https://github.com/platformio/platform-espressif32/releases
    #platform_version: 6.7.0
    platform_version: 6.9.0
    # https://github.com/espressif/esp-idf/releases
    #version: 5.2.2
    version: 5.3.1
    type: esp-idf
    sdkconfig_options:
      CONFIG_FREERTOS_UNICORE: y
    advanced:
      ignore_efuse_mac_crc: true

# Enable logging
logger:
  level: INFO

ota:
  platform: esphome
  password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  reboot_timeout: 0s
  fast_connect: True
  on_connect:
    - esp32_ble_tracker.start_scan:
        continuous: true
  on_disconnect:
    - esp32_ble_tracker.stop_scan:

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  #ap:
  #  ssid: "Bc2500-Ble Fallback Hotspot"

web_server:
  port: 80
  local: true
  version: 3

captive_portal:

interval:
  - interval: 5s
    startup_delay: 20s
    then:
      - script.stop: ble_process
      - script.execute: ble_process
      #- delay: 1500ms
      #- script.execute: ble_process_cmd0F
      #- script.execute:
      #    id: ble_runtime_query0F
      #    ble_device_nr: 1


time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/Berlin

globals:
  - id: ble_1_connected
    type: bool
    initial_value: '0'
  - id: ble_1_initialized
    type: bool
    initial_value: '1'
  - id: internal_console_dbg
    type: bool
    initial_value: '0'
  - id: internal_console_hexdump
    type: bool
    initial_value: '1'
  - id: internal_error_count
    type: int
    initial_value: '0'

  - id: tmp_timers_1
    type: char[22]
    initial_value: "{0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0 }"

esp32_ble:
  id: ble

esp32_ble_tracker:
  scan_parameters:
    window: 300ms
    ### CHECK
    continuous: false
    #active: false

ble_client:
  - mac_address: !secret hm2500_3_mac
    id: bc2500_1
    on_connect:
      then:
        - globals.set:
            id: ble_1_connected
            value: '1'
        - binary_sensor.template.publish:
            id: bool_ble_ok_1
            state: ON
        - text.set:
            id: txt_A01_1
            value: "not connected"
        - text.set:
            id: txt_A02_1
            value: ""
        - text.set:
            id: txt_A03_1
            value: ""
        - text.set:
            id: txt_region_1
            value: ""
        - delay: 250ms
        - script.execute:
            id: ble_set_time
            ble_device_nr: 1
        - script.wait: ble_set_time
              
# set region
#        - script.execute: 
#            id: ble_command_simple
#            ble_device_nr: 1
#            ble_cmd: 0x02
#            ble_cmd_parm: 0x00
#        - script.wait: ble_command_simple
#        - delay: 250ms
    on_disconnect:
      then:
        - binary_sensor.template.publish:
            id: bool_ble_ok_1
            state: OFF
        - globals.set:
            id: ble_1_connected
            value: '0'
        - globals.set:
            id: ble_1_initialized
            value: '1'
        - text.set:
            id: txt_A01_1
            value: "not connected"
        - text.set:
            id: txt_A02_1
            value: ""
        - text.set:
            id: txt_A03_1
            value: ""
        - text.set:
            id: txt_region_1
            value: ""
        - sensor.template.publish:
            id: sensor_device_version_1
            state: 0
#        - binary_sensor.template.publish:
#            id: bool_wifi_ok_1
#            state: OFF
#        - binary_sensor.template.publish:
#            id: bool_mqtt_ok_1
#            state: OFF

button:
  - platform: restart
    id: controller_restart
    name: "Restart ESP32"

#  - platform: template
#    id: test_1_fc41d_qblenotify
#    name: "B01: Test - FC41D enable QBLENOTIFY - ON"
#    on_press:
#      then:
#        - script.execute:
#            id: ble_command_simple
#            ble_device_nr: 1
#            ble_cmd: 0x01
#            ble_cmd_parm: 0x01
#        - script.wait: ble_command_simple

  - platform: template
    id: test_1_cmd04
    name: "B04: Abfrage - Geräteinfo (0x04)"
    on_press:
      then:
        - script.execute:
            id: ble_command_simple
            ble_device_nr: 1
            ble_cmd: 0x04
            ble_cmd_parm: 0x01
        - script.wait: ble_command_simple

  - platform: template
    id: test_1_cmd03
    name: "B03: Abfrage - Laufzeitinfo (0x03)"
    on_press:
      then: 
        - script.execute:
            id: ble_command_simple
            ble_device_nr: 1
            ble_cmd: 0x03
            ble_cmd_parm: 0x01
        - script.wait: ble_command_simple

  - platform: template
    id: test_1_ssid_signal
    name: "B09: Abfrage - WIFI (0x09)"
    on_press:
      then:
        - script.execute:
            id: ble_command_simple
            ble_device_nr: 1
            ble_cmd: 0x09
            ble_cmd_parm: 0x01
        - script.wait: ble_command_simple

  - platform: template
    id: btn_device_1_cells
    name: "B15: Abfrage - Zellinfos intern (0x0F)"
    on_press:
      then:
        - script.execute: 
            id: ble_command_simple
            ble_device_nr: 1
            ble_cmd: 0x0F
            ble_cmd_parm: 0x01
        - script.wait: ble_command_simple

  - platform: template
    id: btn_device_1_timer
    name: "B19: Abfrage - Timer"
    on_press:
      then:
        - if:
            condition:
              lambda: 'return (strcmp(id(txt_A01_1).state.substr(0,3).c_str(), "HMB")==0);'
            then:
              lambda: 'ESP_LOGI("type", "HMB - detected - timer not supported");'
            else:
              - script.execute:
                  id: ble_command_simple
                  ble_device_nr: 1
                  ble_cmd: 0x13
                  ble_cmd_parm: 0x01
              - script.wait: ble_command_simple

  - platform: template
    id: btn_device_1_fc41dfw
    name: "B35: Abfrage - FC41D FW (0x23)"
    on_press:
      then:
        - script.execute:
            id: ble_command_simple
            ble_device_nr: 1
            ble_cmd: 0x23
            ble_cmd_parm: 0x01
        - script.wait: ble_command_simple

  - platform: template
    id: btn_device_1_error1
    name: "B30: Abfrage - Errorlog (0x30/0x1E)"
    on_press:
      then:
        - if:
            condition:
              lambda: 'return ((strcmp(id(txt_A01_1).state.substr(0,3).c_str(), "HMB")==0) && (id(sensor_device_version_1).state > 135));'
            then:
              - script.execute:
                  id: ble_command_simple
                  ble_device_nr: 1
                  ble_cmd: 0x1E
                  ble_cmd_parm: 0x01
              - script.wait: ble_command_simple
            else:
              - script.execute:
                  id: ble_command_simple
                  ble_device_nr: 1
                  ble_cmd: 0x30
                  ble_cmd_parm: 0x01
              - script.wait: ble_command_simple

  - platform: template
    id: btn_device_1_reboot
    name: "B37: Reboot B2500"
    on_press:
      then:
        - script.execute: 
            id: ble_command_simple
            ble_device_nr: 1
            ble_cmd: 0x25
            ble_cmd_parm: 0x01
        - script.wait: ble_command_simple

#  - platform: template
#    id: btn_device_1_factory_settings
#    name: "B38: Factory Settings"
#    disabled_by_default: True
#    on_press:
#      then:
#        - script.execute: 
#            id: ble_command_simple
#            ble_device_nr: 1
#            ble_cmd: 0x26
#            ble_cmd_parm: 0x01
#        - script.wait: ble_command_simple

### set time
#  - platform: template
#    id: test_1_time
#    name: "C01: Test: - Set  Time"
#    on_press:
#      then:
#        - script.execute: 
#            id: ble_set_time
#            ble_device_nr: 1
#        - script.wait: ble_set_time
switch:
  - platform: ble_client
    ble_client_id: bc2500_1
    id: bc2500_1_state
    name: "B01: Bluetooth"

#####################

  - platform: template
    id: switch_debug_hexdump
    name: "B99: INTERNAL:DEBUG HEXDUMP"
    optimistic: True
    #assumed_state: True

  - platform: template
    id: switch_enhanced_cmd0F
    name: "C01: ENHANCED: enable Cell Query (cmd0F)"
    optimistic: True
    #restore_mode: RESTORE_DEFAULT_ON
    #assumed_state: True

text:
  - platform: template
    name: "A01 - Device Type"
    id: txt_A01_1
    optimistic: true
    max_length: 30
    mode: text
  - platform: template
    name: "A02 - Device ID"
    id: txt_A02_1
    optimistic: true
    max_length: 32
    mode: text
  - platform: template
    name: "A03 - MAC"
    id: txt_A03_1
    optimistic: true
    max_length: 30
    mode: text
  - platform: template
    name: "A57: Region"
    id: txt_region_1
    optimistic: true
    max_length: 8
    mode: text
  - platform: template
    name: "A65: Last Response 1"
    id: txt_last_response_1
    optimistic: true
    max_length: 32
    mode: text

binary_sensor:
#  - platform: template
#    name: "A80: Wifi Connected"
#    id: bool_wifi_ok_1
#
#  - platform: template
#    name: "A81: MQTT Connected"
#    id: bool_mqtt_ok_1

  - platform: template
    name: "A82: BLE Connected"
    id: bool_ble_ok_1

sensor:
#  - platform: uptime
#    name: Uptime Sensor
#    filters:
#      - lambda: return x / 3600.0;
#    unit_of_measurement: "hours"
#    accuracy_decimals: 2
  
  - platform: template
    name: "A59: Geräte Version"
    id: sensor_device_version_1
    accuracy_decimals: 0

  - platform: ble_client
    ble_client_id: bc2500_1
    internal: True
    type: characteristic
    name: "infoX2a"
    id: infoX2a
    service_uuid: 'ff00'
    characteristic_uuid: 'ff02'
    notify: True
    lambda: |-
      std::vector<char> tData;
      for (auto b : x) { tData.push_back(b); }
      id(ble_notify_parse).execute(1,tData);
      return (float)x[0];

script:

# ble communication
#
# NOTE: this is a copy of the V1 Changes ... everthing 'til 1.38 belongs to V1 ... and dont neccessary are included/used in V2-FW 
#       I started with V1.60 on V2, so some commands maybe included earlier into V2-FW ...
#
#
# action ( 00f1 )
#
# head    = 0x73
# length  = len(paket)
# cntl    = 0x23
# cmd     = 0x02  set Region      1Byte   (0x00 = EU / 0x01 = China / 0x02 = Non-EU / 0xff = not SET)
#         = 0x03  runtimeInfo     1Byte   (0x01)
#         = 0x04  DeviceInfo      1Byte   (0x01)
#         = 0x0B  DOD             1Byte   (0-100)
#         = 0x0C  Entladeschwelle 2Byte   (0-999)
#         = 0x0D  PV2-Passthrough  1Byte   (0x00 on / 0x01 off)
#         = 0x0E  PowerOut        1Byte   (0x00 1-2 off / 0x01 1 on / 0x02 2 on / 0x03 1-2 on)
#
#         = 0x05  Wifi-Config     xByte   ( ssid<.,.>pwd )
#         = 0x08  Wifi-State      1Byte   (0x01)  ????
#
#         following mqtt parts not implemented - outdated or not implemented in fw <= 1.34
#         have a look at 0x20/0x21 in 1.34
#         q&d c&p - more details will be added, maybe ...
#         = 0x14  set AWS MQTT    xByte   ( url<.,.>Port ) ....
#         = 0x60  set MQTT Certs  xByte   ( 0x00 = client.key / 0x01 = client.crt / 0x02 = ca.crt + cert len  )
#         = 0x61  trans MQTT Certs xByte  ( jeweils 128bytes des certs  )
#         = 0x62  end MQTT Certs  xByte   (   )
#
#         testing / notes
#         = 0x01  Debug ?!?! ( BLE-Serial ) 1Byte   (0x00 = off / 0x01 = on) - enables QBLEGATTSNOTIFY notify 1 / 81 ( entspricht ~ runtimeinfo )
#         = 0x14  not for mqtt ... set localtime ??? for auth/certs/challenge requests ????? ( query/set wifi depends ????)
#
#         new 1.31
#         = 0x0F  new in fw 131 1Byte   ( 0x01 ) - soc_temp1_temp2_14-cell-voltage(s)
#         = 0x30 found in logs ...      ( 0x01 ) - ???? unknown answers since fw 131
#
#         new 1.34
#         = 0x09  SSID / SignalStrength ( 0x01 )
#         = 0x20  mqtt related - set server/port ? - see new in 1.37
#         = 0x21  mqtt related - set keys ?        
#         = 0x23  get FC41D Version     ( 0x01 )
#         = 0x24  undocumented*
#         = 0x25  Reboot                ( 0x01 )
#         = 0x26  Factory Settings      ( 0x01 )
#
#         new 1.37
#         = 0x20  set own MQTT
#                 0|1<.,.>HOST<.,.>PORT<.,.>USER<.,.>PASSWD<.,.>"
#                 0   = no ssl
#                 1   = encryption
#                 note: leaving user/passwd empty works ...
#
#         unknown ...
#         = 0x1e  unknown - error related ?!?!? (0x30)
#
#
#         #### V2 #####
#         ( see note in top of doc )
#
#         new 1.60
#         = 0x11  00 - enable adaptiv - set all in/out off ????
#         = 0x12  set timers
#         = 0x13  get timers
#
#         new 212.18
#         = 0x21  01  - reset to original mqtt ( amazon/hametech - app/remote )
#
#         new 217.18
#         = 0x2a  01    - ???
#         = 0x2b  01    - ???
#         = 0x2c  parms - ???
#
#
# data    = xx xx xx xx xx xx .... / depends on cmd
# crc     = xor len(paket) - 1 
#
#
# responses ( ff02 ):
#
# head    = 0x73
# length  = len(paket)
# cntl    = 0x23
# cmd     = cmd
# data    = xx xx xx xx xx ....
#
#
#
################ maybe direct for arm
# send ( ff01 )
#
# head1    = 0xAA
# head2(?) = 0x55 ( not length ?!?!? )
# cmd      = 1x / 2x / 3x ( flash - 30 "open"/ 31 - write / 32 "close" ) / 5x
# data     = xx xx xx xx xx ....
# crc      = xor len(paket) -1 
#
################ maybe direct for bms
# send/receive ( ff06 ) 
#
# head    = 0xAA
# len     = 0x05/0x03
# data    = xx xx xxx ( xx xx )
# crc     = x1 + x2 + ... + xn
#
#
#   f.ex hw-reset 
#
#  -> aa 05 01 00 01 01 00 08
#  <- aa 01 00 01
#
#  -> aa 05 01 00 01 00 00 07
#  <- aa 01 00 01
#

  - id: ble_command_simple
    mode: queued
    parameters:
      ble_device_nr: int
      ble_cmd: int
      ble_cmd_parm: int
    then:
      - logger.log:
          level: INFO
          format: "ble command send: %i [0x%02X] %i"
          args: [ 'ble_device_nr','ble_cmd','ble_cmd_parm' ]
      - if:
          condition:
            lambda: 'return (ble_device_nr == 1);'
          then:
            - ble_client.ble_write:
                id: bc2500_1
                #service_uuid: 'ff00'
                #characteristic_uuid: 'ff01'
                service_uuid: 0000ff00-0000-1000-8000-00805f9b34fb
                characteristic_uuid: 0000ff01-0000-1000-8000-00805f9b34fb
                value: !lambda |-
                  std::vector<unsigned char> rdat1{ 0x73,0x06,0x23,(unsigned char)ble_cmd};

                  if (ble_cmd == 0x0C) {
                    rdat1.push_back((uint8_t)((ble_cmd_parm >> 0) & 0xFF));
                    rdat1.push_back((uint8_t)((ble_cmd_parm >> 8) & 0xFF));
                  } else {
                    rdat1.push_back((unsigned char)ble_cmd_parm);
                  }

                  int rlen = rdat1.size();
                  rdat1.at(1) = rlen+1;
                  int rxor = 0;
                  for (int i=0;i<rlen;i++) {
                    rxor = rxor ^ rdat1[i];
                  }
                  rdat1.push_back(rxor);

                  if (id(internal_console_dbg)) {
                    for (auto b : rdat1) {
                      ESP_LOGD("COMMAND", "%x - %i - %c", b,b,b);
                    }
                  }

                  return rdat1;

  - id: ble_command_string
    parameters:
      ble_device_nr: int
      ble_cmd: int
      ble_cmd_parm: string
    then:
      - logger.log:
          level: INFO
          format: "ble command send string: %i [0x%02X]"
          args: [ 'ble_device_nr','ble_cmd']
      - if:
          condition:
            lambda: 'return (ble_device_nr == 1);'
          then:
            - ble_client.ble_write:
                id: bc2500_1
                #service_uuid: 'ff00'
                #characteristic_uuid: 'ff01'
                service_uuid: 0000ff00-0000-1000-8000-00805f9b34fb
                characteristic_uuid: 0000ff01-0000-1000-8000-00805f9b34fb
                value: !lambda |-
                  std::vector<unsigned char> rdat1{ 0x73,0x06,0x23,(unsigned char)ble_cmd};

                  // fc41d fw
                  if ( ble_cmd == 0x24) { rdat1.push_back(0xaa); }

                  for (auto b : ble_cmd_parm) {
                    rdat1.push_back((unsigned char)b);
                  }
                    
                  int rlen = rdat1.size();
                  rdat1.at(1) = rlen+1;
                  int rxor = 0;
                  for (int i=0;i<rlen;i++) {
                    rxor = rxor ^ rdat1[i];
                  }
                  rdat1.push_back(rxor);
            
                  if (id(internal_console_dbg)) {
                    for (auto b : rdat1) {
                      ESP_LOGD("COMMAND", "%x - %i - %c", b,b,b);
                    }
                  }

                  return rdat1;

  - id: ble_command_raw_01
    parameters:
      ble_device_nr: int
      ble_cmd_parm: char[]
    then:
      - logger.log:
          level: INFO
          format: "ble command send (raw): %i"
          args: [ 'ble_device_nr']
      - if:
          condition:
            lambda: 'return (ble_device_nr == 1);'
          then:
            - ble_client.ble_write:
                id: bc2500_1
                service_uuid: 0000ff00-0000-1000-8000-00805f9b34fb
                characteristic_uuid: 0000ff01-0000-1000-8000-00805f9b34fb
                value: !lambda |-
                  std::vector<unsigned char> rdat1;

                  for (auto b : ble_cmd_parm) {
                    rdat1.push_back((unsigned char)b);
                  }

                  int rlen = rdat1.size();
                  rdat1.at(1) = rlen+1;
                  int rxor = 0;
                  for (int i=0;i<rlen;i++) {
                    rxor = rxor ^ rdat1[i];
                  }
                  rdat1.push_back(rxor);

                  //if (id(internal_console_dbg)) {
                    for (auto b : rdat1) {
                      ESP_LOGD("COMMAND raw", "%x - %i - %c", b,b,b);
                    }
                  //}

                  return rdat1;
                  

  - id: ble_process
    then:
      - if:
          condition:
            - lambda: 'return (id(ble_1_connected) && id(ble_1_initialized) && (id(txt_A02_1).state == ""));'
          then:
            - script.execute: 
                id: ble_command_simple
                ble_device_nr: 1
                ble_cmd: 0x04
                ble_cmd_parm: 0x01
            - script.wait: ble_command_simple
      - delay: 1s
      - if:
          condition:
            - lambda: 'return (id(ble_1_connected) && id(ble_1_initialized) && (id(txt_region_1).state == "" ));'
          then:
            - script.execute:
                id: ble_command_simple
                ble_device_nr: 1
                ble_cmd: 0x03
                ble_cmd_parm: 0x01
            - script.wait: ble_command_simple

  - id: ble_process_cmd0F
    then:
      - if:
          condition:
            - lambda: 'return (id(ble_1_connected) && id(ble_1_initialized) && id(switch_enhanced_cmd0F).state);'
          then:
            ### query cmd0F if firmware > 1.33
            - if:
                condition:
                  - lambda: 'return (id(sensor_device_version_1).state  > 133 && id(txt_A02_1).state != "");'
                then:
                  - script.stop: ble_runtime_query0F
                  - script.execute: 
                      id: ble_runtime_query0F
                      ble_device_nr: 1
                  - script.wait: ble_runtime_query0F

  - id: ble_runtime_query
    parameters:
      ble_device_nr: int
    then:
      - logger.log: 
          format: "runtime query: %i"
          args: [ 'ble_device_nr' ]      
      - script.execute: 
          id: ble_command_simple
          ble_device_nr: !lambda return ble_device_nr;
          ble_cmd: 0x03
          ble_cmd_parm: 0x01
      - script.wait: ble_command_simple

  - id: ble_runtime_query30
    parameters:
      ble_device_nr: int
    then:
      - logger.log: 
          level: INFO
          format: "runtime query 30 (errorlog ?): %i"
          args: [ 'ble_device_nr' ]      
      - script.execute: 
          id: ble_command_simple
          ble_device_nr: !lambda return ble_device_nr;
          ble_cmd: 0x30
          ble_cmd_parm: 0x01
      - script.wait: ble_command_simple

  - id: ble_runtime_query0F
    parameters:
      ble_device_nr: int
    then:
      - logger.log: 
          format: "runtime query 0F (cellinfos): %i"
          args: [ 'ble_device_nr' ]      
      - script.execute: 
          id: ble_command_simple
          ble_device_nr: !lambda return ble_device_nr;
          ble_cmd: 0x0F
          ble_cmd_parm: 0x01
      - script.wait: ble_command_simple

  - id: ble_runtime_query13
    parameters:
      ble_device_nr: int
    then:
      - logger.log:
          format: "runtime query 13 (timer): %i"
          args: [ 'ble_device_nr' ]
      - script.execute:
          id: ble_command_simple
          ble_device_nr: !lambda return ble_device_nr;
          ble_cmd: 0x13
          ble_cmd_parm: 0x00
      - script.wait: ble_command_simple

  - id: ble_set_time
    parameters:
      ble_device_nr: int
    then:   
      - logger.log: 
          format: "set time: %i"
          args: [ 'ble_device_nr' ]
      - if:
          condition:
            lambda: 'return (ble_device_nr == 1);'
          then:
            - ble_client.ble_write:
                id: bc2500_1
                service_uuid: 'ff00'
                characteristic_uuid: 'ff01'
                #service_uuid: 0000ff00-0000-1000-8000-00805f9b34fb
                #characteristic_uuid: 0000ff01-0000-1000-8000-00805f9b34fb
                value: !lambda |-
                  std::vector<unsigned char> rdat1{ 0x73,0x0d,0x23,0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00 };
    
                  auto time = id(sntp_time).now();
                  rdat1.at(4) = time.year - 1900;
                  rdat1.at(5) = time.month;
                  rdat1.at(6) = time.day_of_month;
                  rdat1.at(7) = time.hour;
                  rdat1.at(8) = time.minute;
                  rdat1.at(9) = time.second;

                  int rlen = rdat1.size();
                  rdat1.at(1) = rlen+1;
                  int rxor = 0;
                  for (int i=0;i<rlen;i++) {
                    rxor = rxor ^ rdat1[i];
                  }
                  rdat1.push_back(rxor);

                  return rdat1;
                                                                
  - id: ble_notify_parse
    parameters:
      ble_device_nr: int
      x: char[]
    then:
      - logger.log: 
          level: INFO
          format: "runtime parse: %i"
          args: [ 'ble_device_nr' ]
      - lambda: |-
          ESP_LOGD("notify_parse", "Device: %i", ble_device_nr);
          /*if (id(internal_console_dbg)) {
            ESP_LOGD("parse", "x[3] = %i", x[3]);
              for (auto b : x) {
                ESP_LOGD("data", "%.2x \t %i \t %c", b,b,b);
              }
          }*/

          if (id(switch_debug_hexdump).state == true) {
            ESP_LOG_BUFFER_HEXDUMP("hexdump", &x[0], x.size(), ESP_LOG_ERROR);
          }          

          auto strTime = id(sntp_time).now().strftime("%d.%m.%Y %H:%M:%S");
          if (ble_device_nr==1) { id(txt_last_response_1).publish_state(strTime); }

          if ((std::count (x.begin(), x.end(), '_') == 16) || (std::count (x.begin(), x.begin() + 10, '_') == 3)) 
          {   
            ESP_LOGD("main", "Data: cmd 0x0F");
            int pos = 0;
            int soc = 0;
            int t1 = 0;
            int t2 = 0;
            float cv = 0.0; 
            float cmin = std::numeric_limits<float>::max();
            float cmax = std::numeric_limits<float>::min();
            float ct = 0.0;
            int found = -1;
            char delimiter = '_';
            std::string xstr; 
            std::vector<float> cellV;
        
            xstr.assign(x.begin(), x.end());                                // copy values from vector into string xstr, deep copy
            xstr = xstr + delimiter;                                        // append delimiter to xstr 
            found = xstr.find(delimiter);                                   // search for position of the first delimiter
            while (found != -1)                                             // loop until no more delimiter found
            { 
              if(pos == 0) soc = atoi( xstr.substr(0, found).c_str());                                                                         // pos 0 don't care
              if(pos == 1) t1 = atoi( xstr.substr(0, found).c_str());       // pos 1 get int value of temperature sensor 1
              if(pos == 2) t2 = atoi( xstr.substr(0, found).c_str());       // pos 2 get int value of temperature sensor 2
              if((pos >= 3) && (pos <= 16))                                 // pos 3-16 parse pos for the 14 cell voltages
              {                                                             
                ct = atof( xstr.substr(0, found).c_str());                  // get float value of pos x
                cellV.push_back(ct);
                //ESP_LOGD("cell voltage", ct.c_str());
                cv += ct;                                                   // add actual value to var cv
                if(ct > cmax) cmax = ct;                                    // check for higher value as stored in cmax
                if(ct < cmin) cmin = ct;                                    // check for lower value as stored in cmin
              }
              xstr.erase(xstr.begin(), xstr.begin() + found + 1);           // remove parsed string part
              found = xstr.find(delimiter);                                 // find next delimiter
              pos++;                                                        // increment pos
            }

            /* calculate SoC from cell voltages
                 cell empty = 3.0 Volt  =  0% SoC
                 cell full  = 3.5 Volt  = 100% SoC
            */

            // float soccalc =  (cv/14000 - 3.0) * 200;
            float lowlimit  = 3.050;                                           // low voltage limit
            //float highlimit = 3.328;                                         // high voltage limit
            float highlimit = 3.400;
                                                                    
            float soccalc =  100*((cv/14000) 
                              - highlimit)/(highlimit - lowlimit) + 100;     // equation of line with two points (0,lowlimit) (100,highlimit)

            ESP_LOGI("cellVoltage","soc: %i, temp1: %i, temp2: %i",soc,t1,t2);
            ESP_LOGI("cellVoltage","cell01: %.f, cell 02: %.f, cell 03: %.f, cell 04: %.f", cellV[0], cellV[1], cellV[2], cellV[3]);
            ESP_LOGI("cellVoltage","cell05: %.f, cell 06: %.f, cell 07: %.f, cell 08: %.f", cellV[4], cellV[5], cellV[6], cellV[7]);
            ESP_LOGI("cellVoltage","cell09: %.f, cell 10: %.f, cell 11: %.f, cell 12: %.f", cellV[8], cellV[9], cellV[10], cellV[11]);
            ESP_LOGI("cellVoltage","cell13: %.f, cell 14: %.f", cellV[12], cellV[13]);

            ESP_LOGI("cellVoltage","csum: %.3f, cavg: %.3f, cmin: %.3f, cmax: %.3f, cdiff: %.3f", cv/1000, cv/14000, cmin/1000, cmax/1000, (cmax-cmin)/1000);
          }   

          else if (x[3] == 0x03) {
            ESP_LOGD("main", "Data: runtimeInfo ");

            //sensor
            // pv_level 1 und 2
            /*
              [6][7]  PV-Eingangsleistung 1 (2Byte)
              [8][9]  PV-Eingangsleistung 2 (2Byte)
                      x[Y] | x[Z] << 8;
            */
            int pvPower1 = x[6] | x[7] << 8;
            int pvPower2 = x[8] | x[9] << 8;
            ESP_LOGI("runtimeInfo","PV IN 1: %i W", pvPower1);
            ESP_LOGI("runtimeInfo","PV IN 2: %i W", pvPower2);
            ESP_LOGI("runtimeInfo","PV IN S: %i W", pvPower1 + pvPower2);

            // Batterie Stand in %
            /*
              [10][11]  Verbleibende Batteriekapazität in Prozent (2Byte)
                        x[Y] | x[Z] << 8;
            */
            int batRemain = x[10] | x[11] << 8 ;
            ESP_LOGI("runtimeInfo","Batteriestand: %i", batRemain / 10);

            // Entladen bei weniger als ??? Watt PV Eingang
            /*
              [19][20]  Entladeschwelle(2Byte)
                        x[Y] | x[Z] << 8;
            */
            int disCharge = x[19] | x[20] << 8;
            ESP_LOGI("runtimeInfo","Entladeschwelle: %i ", disCharge);

            // Füllstand des Akkus in Wh
            /*
              [22][23]  Gesamtkapazität der Batterie (1Byte)
                        x[Y] | x[Z] << 8;
            */
            int batCapacity = x[22] | x[23] << 8;
            ESP_LOGI("runtimeInfo","Ladestand: %i Wh", batCapacity);

            // Ausgangsleistung in Watt
            /*
              [24][25]  Ausgangsleistung 1(1Byte)
              [26][27]  Ausgangsleistung 2(1Byte)
                        x[Y] | x[Z] << 8;
            */
            int powerOut1 = x[24] | x[25] << 8;
            int powerOut2 = x[26] | x[27] << 8;
            ESP_LOGI("runtimeInfo","Power Out 1: %d W", powerOut1);
            ESP_LOGI("runtimeInfo","Power Out 2: %d W", powerOut2);
            ESP_LOGI("runtimeInfo","Power Out S: %d W", powerOut1 + powerOut2);

            // Geräte Version ( Firmware ? )
            /*
              [12]  B2500 Geräteversion (1Byte)
                    0-255 ( ~ anzeige als /100 )
            */
            int dev_version = x[12];
            ESP_LOGI("runtimeInfo","Geräteversion: %i", dev_version);
            if (ble_device_nr==1) { id(sensor_device_version_1).publish_state(dev_version); }

            // Temperature Sensors 
            /*
              [33]  Temp 1
              [35]  Temp 2
            */
            int dev_temp1 = x[33];
            int dev_temp2 = x[35];
            ESP_LOGI("runtimeInfo","Temperatur 1: %i", dev_temp1);
            ESP_LOGI("runtimeInfo","Temperatur 2: %i", dev_temp2);
            
            /*
              [18]  Dod (1Byte)
                    0-100 Prozentualer Anteil der Entladeleistung an der Nennleistung
            */
            int dod_level = x[18];
            ESP_LOGI("runtimeInfo","DOD: %i", dod_level);

            // binary sensor / bool
            // pv 1 und 2 in
            /*
                [x4]  PV IN 1 Zustand (1Byte) 
                [x5]  PV IN 2 Zustand (1Byte) 
                      0x00 （off）
                      0x01 （Aufladung）
                      0x02 （transparent für Wechselrichter）
            */
            if ( x[4] == 0x00 ) { ESP_LOGI("runtimeInfo","PV IN 1: Deaktiv"); }
            if ( x[4] == 0x01 ) { ESP_LOGI("runtimeInfo","PV IN 1: Aktiv"); }
            if ( x[4] == 0x02 ) { ESP_LOGI("runtimeInfo","PV IN 1: Transparent"); }
            if ( x[5] == 0x00 ) { ESP_LOGI("runtimeInfo","PV IN 2: Deaktiv"); }
            if ( x[5] == 0x01 ) { ESP_LOGI("runtimeInfo","PV IN 2: Aktiv"); }
            if ( x[5] == 0x02 ) { ESP_LOGI("runtimeInfo","PV IN 2: Transparent"); }

            // Entlademodus 
            /*
                [13]  Einstellung des Ladevorgangs (1Byte)
                      0x00 （Simultanes Laden/Entladen）
                      0x01 （Erst Laden, dann Entladen）
            */

            if (strcmp(id(txt_A01_1).state.substr(0,3).c_str(), "HMB")==0) {
              if( x[13] == 0x00 ) { ESP_LOGI("runtimeInfo","Ladeeinstellungen: PV1 Aufladung PV2 Durchleitung"); }
              if( x[13] == 0x01 ) { ESP_LOGI("runtimeInfo","Ladeeinstellungen: Erst Laden"); }
            }
            else {
              if( x[13] == 0x00 ) { ESP_LOGI("runtimeInfo","Ladeeinstellungen: Gleichzeitg Laden/Entladen"); }
              if( x[13] == 0x01 ) { ESP_LOGI("runtimeInfo","Ladeeinstellungen: Erst Laden"); }
            }

            // RESERVED ( wifi / mqtt )
            /*
                [15]  Reserve(1Byte)
                      0x00 wifi funktioniert nicht
                      0x01 wifi ok, mqtt nicht verbunden
                      0x02 wifi ok, mqtt connect ok
                      NEW:
                      maybe wifi / mqtt
                      00 = false / false
                      01 = true / false
                      02 = false / true
                      03 = true / true
                      -------
                      first part means not wifi connected ?!?!? 
                      00 = ??? / mqtt not connected
                      01 = ??? / mqtt not connected
                      02 = ??? / mqtt connected
                      03 = ??? / mqtt connected                      
            */
            // wifi and mqtt
            if (ble_device_nr==1) { 
              if ( x[15] == 0x00 || x[15] == 0x02 ) { ESP_LOGI("runtimeInfo","WIFI: OFF"); }
              else { ESP_LOGI("runtimeInfo","WIFI: Connected"); }
              if ( x[15] == 0x00 || x[15] == 0x01 ) { ESP_LOGI("runtimeInfo","MQTT: OFF"); }
              else { ESP_LOGI("runtimeInfo","MQTT: Connected"); }
            }

            // power 1 und 2 enabled/disabled
            /*
                [14]  Entlade-Modus / Enabled (1Byte)
                      0x00 OUT1&OUT2 Sperren
                      0x01 nur OUT1 Freigabe
                      0x02 nur OUT2 Freigabe
                      0x03 OUT1&OUT2 Freigabe        

                      NEED
            */
            if (ble_device_nr==1) {
              if (strcmp(id(txt_A01_1).state.substr(0,3).c_str(), "HMB")==0) {
                switch(x[14]) {
                  case 0:
                    ESP_LOGI("runtimeInfo","Ausgang: OUT1: Off / OUT2: Off");
                    break;
                  case 1:
                    ESP_LOGI("runtimeInfo","Ausgang: OUT1: On / OUT2: Off");
                    break;
                  case 2:
                    ESP_LOGI("runtimeInfo","Ausgang: OUT1: Off / OUT2: On");
                    break;
                  case 3:
                    ESP_LOGI("runtimeInfo","Ausgang: OUT1: On / OUT2: On");
                    break;
                }
              } 
            }

            /*
                [16]  Ausgang Port 1 Status (1Byte)
                [17]  Ausgang Port 2 Status (1Byte)
                      0x00（Aus）
                      0x01（Entladung）
            */
            if (ble_device_nr==1) { 
              if ( x[16] == 0x00 ) { ESP_LOGI("runtimeInfo","OUT 1: Deaktiv"); }
              if ( x[16] == 0x01 ) { ESP_LOGI("runtimeInfo","OUT 1: Aktiv"); }
              if ( x[17] == 0x00 ) { ESP_LOGI("runtimeInfo","OUT 2: Deaktiv"); }
              if ( x[17] == 0x01 ) { ESP_LOGI("runtimeInfo","OUT 2: Aktiv"); }
            }
            // zusatzakku 1 und 2
            /*
                [28]  Ist Netzgerät 1 angeschlossen (1Byte)
                [29]  Ist Netzgerät 2 angeschlossen (1Byte)
                      0x00（Kein Akkupack angeschlossen）
                      0x01（Verbinden Sie das Netzteil）        
            */
            if ( x[28] == 0x00 ) { ESP_LOGI("runtimeInfo","Powerpack 1: OFF"); }
            if ( x[28] == 0x01 ) { ESP_LOGI("runtimeInfo","Powerpack 1: verbunden"); }
            if ( x[29] == 0x00 ) { ESP_LOGI("runtimeInfo","Powerpack 2: OFF"); }
            if ( x[29] == 0x01 ) { ESP_LOGI("runtimeInfo","Powerpack 2: verbunden"); }

            if (ble_device_nr==1) { 
              switch(x[21]) {
                case 0x00: 
                  ESP_LOGI("runtimeInfo","Scene: Stark");
                case 0x01:
                  ESP_LOGI("runtimeInfo","Scene: Schwach");
                case 0x02:
                  ESP_LOGI("runtimeInfo","Scene: Mittel");
              }
            }
        
            if (ble_device_nr==1) { 
              auto call_30 = id(txt_region_1).make_call(); 
              if( x[30] == 0x00 ) { call_30.set_value("EU"); }
              if( x[30] == 0x01 ) { call_30.set_value("China"); }
              if( x[30] == 0x02 ) { call_30.set_value("non-EU"); }
              if( x[30] == 0xff ) { call_30.set_value("not SET"); }
              call_30.perform();
            }
          }
          else if (x[3] == 0x04) {
            ESP_LOGD("main", "Data: deviceInfo ");
            //for (auto b : x) {
            //  ESP_LOGD("data", "%i", b);
            //}
            //  's<#?type=<5>,id=<24>,mac=<12>t'
            // ESP_LOGD("data", "%s", vType);
            int data_len = x.size();

            unsigned char vType[8];
            for (int i=9;i<14;i++) {
              vType[i-9] = x[i];
            }
            vType[5] = 0x00;
        
            unsigned char vID[32];
            for (int i=18;i<42;i++) {
              vID[i-18] = x[i];
            }
            vID[24]=0x00;
        
            unsigned char vMac[16];
            for (int i=47;i<59;i++) {
              vMac[i-47] = x[i];
            }
            vMac[12] = 0x00;

            ESP_LOGI("deviceInfo", "%i: %s [%s] %s", data_len,vType,vMac,vID);
            std::string sType(reinterpret_cast<char*>(vType));
            std::string sID(reinterpret_cast<char*>(vID));
            std::string sMac(reinterpret_cast<char*>(vMac));
            if (ble_device_nr==1) { id(txt_A01_1).publish_state(sType); id(txt_A02_1).publish_state(sID); id(txt_A03_1).publish_state(sMac); }
          }
          else if (x[3] == 0x09) {          
            ESP_LOGD("main", "Data: WIFI");
            int data_len = x.size();
            unsigned int vSignal;
            unsigned char vSSID[32];

            vSignal = int(x[4]);

            for (int i=6;i<data_len;i++) {
              vSSID[i-6] = char(x[i]);
            }
            vSSID[data_len-6] = 0x00;
            ESP_LOGI("WIFI", "SSID: %s",vSSID);
            ESP_LOGI("WIFI", "Strength: %i", vSignal);
          }
          else if (x[3] == 0x23) {          
            ESP_LOGD("main", "Data: fc41d FW ");            
            int data_len = x.size();
            unsigned char vFC41D_FW[16];

            for (int i=4;i<data_len-2;i++) {
              vFC41D_FW[i-4] = char(x[i]);
            }
            vFC41D_FW[data_len-6] = 0x00;
            ESP_LOGI("FC41D FW", "%i: %s", data_len,vFC41D_FW);
            //std::string sFC41D_FW(reinterpret_cast<char*>(vFC41D_FW));
            //if (ble_device_nr==1) { id(txt_A12_1).publish_state(sFC41D_FW); }
          }
          else if (x[3] == 0x30) {
            ESP_LOGI("main", "Data: cmd 0x30");
            int data_len = x.size();
            ESP_LOGI("data 30 - raw" , "Device %i",ble_device_nr);
            //ESP_LOG_BUFFER_HEXDUMP("hexdump", &x[0], x.size(), ESP_LOG_ERROR);
            for(int i=5;i<data_len-1;i++) {
              long long int data1 = x[i+4] | x[i+3] << 8 | x[i+2] << 16 | x[i+1] << 24;
              long long int data2 = x[i+8] | x[i+7] << 8 | x[i+6] << 16 | x[i+5] << 24;

              const time_t time_c = (time_t)data1;
              struct tm *time_tm = gmtime(&time_c);

              char str_time[32];
              std::string str_diz;
              strftime(str_time, sizeof(str_time), "%Y-%m-%d %H:%M:%S", time_tm);
              
              if (strcmp(id(txt_A01_1).state.substr(0,3).c_str(), "HMB")==0) {
                auto it = errorMap1.find(x[i]);
                if (it != errorMap1.end()) {
                  str_diz = it->second;
                } else {
                  str_diz = "unknown errorcode 1";
                }
              } else {
                auto it = errorMap2.find(x[i]);
                if (it != errorMap2.end()) {
                  str_diz = it->second;
                } else {
                  str_diz = "unknown errorcode 2";
                }
              }                

              ESP_LOGI("errorlog" , "%d - %s - %s : %lld", x[i], str_time, str_diz.c_str(), data2);
              i += 8;
            }
          }
          else if (x[3] == 0x13) {
            ESP_LOGI("main", "Data: cmd 0x13 (timer) - Device: %i",ble_device_nr );
            int data_len = x.size();
            ESP_LOGI("timer" , "1: %i: %02i:%02i - %02i:%02i ( %3i W )", x[5], x[6],x[7],x[8],x[9],(x[11] << 8) | x[10]);
            ESP_LOGI("timer" , "2: %i: %02i:%02i - %02i:%02i ( %3i W )", x[12], x[13],x[14],x[15],x[16],(x[18] << 8) | x[17]);
            ESP_LOGI("timer" , "3: %i: %02i:%02i - %02i:%02i ( %3i W )", x[19], x[20],x[21],x[22],x[23],(x[25] << 8) | x[24]);
            ESP_LOGI("timer" , "adaptiv: %i - Entladeleistung: %03i - CT001: %03i ( %03i s )", x[26],(x[28] << 8) | x[27],(x[30] << 8) | x[29],(x[32] << 8) | x[31]);

            // smartmeter
            //snprintf(mtopic, 48,"b2500v1/%i/smartmeter/enabled",ble_device_nr);
            //id(mqtt_client).publish(mtopic,to_string(x[4]));
          }
          else {
            ESP_LOG_BUFFER_HEXDUMP("hexdump", &x[0], x.size(), ESP_LOG_ERROR);
          }

